///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>
///<reference path="WorldGraph.ts"/>

module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    import Literal = Interpreter.Literal;
    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations:Interpreter.InterpretationResult[], currentState:WorldState):PlannerResult[] {
        var errors:Error[] = [];
        var plans:PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result:PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch (err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    function goalReached(state:WorldState, interpretation:Interpreter.DNFFormula):boolean {
        for (var i = 0; i < interpretation.length; i++) {
            for (var j = 0; j < interpretation[i].length; j++) {
                var literal = interpretation[i][j];
                var relation = literal.relation;

                if (relation === "holding" && state.holding === literal.args[0]) {
                    return true;
                } else {
                    var fKey = [literal.args[0]];
                    var sKey = [literal.args[1]];

                    //if this goal interpretation is reached, checkBinaryConstraint
                    //will return a nonempty list
                    var isGoal = Interpreter.checkBinaryConstraint(sKey, fKey, relation, state);
                    if (isGoal.length === 1) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    var NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK = 3;

    function chooseCheapestLiteral(state:WorldState, interpretation:Interpreter.DNFFormula):number {
        var literal = interpretation[0][0];
        var oldHeuristic:number;
        var heuristicFunc:(l:Literal, s:WorldState) => number;
        var relation : string = literal.relation;

        switch (relation) {
            case "holding":
                heuristicFunc = holdingHeuristic;
                break;
            case "inside":
            case "ontop":
            case "under":
                heuristicFunc = insideOrOntopOrBelowHeuristic;
                break;
            case "beside":
                heuristicFunc = besideHeuristic;
                break;
            case "leftof":
                heuristicFunc = leftOfHeuristic;
                break;
            case "rightof":
                heuristicFunc = rightOfHeuristic;
                break;
            case "above":
                heuristicFunc = aboveHeuristic;
                break;
        }

        oldHeuristic = heuristicFunc(literal, state);
        for (var i = 0; i < interpretation.length; i++) {
            for (var j = 0; j < interpretation[i].length; j++) {
                var tmp = heuristicFunc(interpretation[i][j], state);
                if (tmp < oldHeuristic) {
                    oldHeuristic = tmp;
                    literal = interpretation[i][j];
                }
            }
        }

        return oldHeuristic;
    }

    function besideHeuristic(literal : Literal, state : WorldState) {
        var key1 = literal.args[0];
        var key2 = literal.args[1];
        var key1StackIndex = Interpreter.findStackIndex(key1, state);
        var key2StackIndex = Interpreter.findStackIndex(key2, state);

        var distance : number = Math.abs(Math.abs(key2StackIndex - key1StackIndex) - 1);

        if(state.holding === key1 || state.holding === key2) {
            return distance;
        }

        return distance +
            Math.min(
                objectsAboveKey(key1, state.stacks[key1StackIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK,
                objectsAboveKey(key2, state.stacks[key2StackIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK
            );
    }

    function leftOfHeuristic(literal : Literal, state : WorldState) {
        var key1 = literal.args[0];
        var key2 = literal.args[1];

        if(state.holding === key1) {
            return Math.abs(state.arm - Interpreter.findStackIndex(key2, state));
        }

        if(state.holding === key2) {
            return Math.abs(state.arm - Interpreter.findStackIndex(key1, state));
        }

        var key1StackIndex = Interpreter.findStackIndex(key1, state);
        var key2StackIndex = Interpreter.findStackIndex(key2, state);

        var distance : number = Math.abs(key2StackIndex - key1StackIndex);

        if(key2StackIndex < key1StackIndex) {
            return 0;
        } else {
            if(key2StackIndex === 0) {
                return objectsAboveKey(key2, state.stacks[key2StackIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK +
                        distance;
            } else {
                return distance + Math.min(
                        objectsAboveKey(key1, state.stacks[key1StackIndex]),
                        objectsAboveKey(key2, state.stacks[key2StackIndex])) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK;
            }
        }
    }

    function rightOfHeuristic(literal : Literal, state : WorldState) {
        var key1 = literal.args[0];
        var key2 = literal.args[1];

        if(state.holding === key1) {
            return Math.abs(state.arm - Interpreter.findStackIndex(key2, state));
        }

        if(state.holding === key2) {
            return Math.abs(state.arm - Interpreter.findStackIndex(key1, state));
        }

        var key1StackIndex : number = Interpreter.findStackIndex(key1, state);
        var key2StackIndex : number = Interpreter.findStackIndex(key2, state);

        var distance : number = Math.abs(key2StackIndex - key1StackIndex);

        if(key2StackIndex > key1StackIndex) {
            return 0;
        } else {
            if(key2StackIndex === state.stacks.length - 1) {
                return objectsAboveKey(key2, state.stacks[key2StackIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK +
                    distance;
            } else {
                return distance + Math.min(
                        objectsAboveKey(key1, state.stacks[key1StackIndex]),
                        objectsAboveKey(key2, state.stacks[key2StackIndex])) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK;
            }
        }
    }

    function aboveHeuristic(literal : Literal, state : WorldState) {
        var key1 = literal.args[0];
        var key2 = literal.args[1];

        if(state.holding === key1) {
            return Math.abs(state.arm - Interpreter.findStackIndex(key2, state));
        }
        var key1StackIndex = Interpreter.findStackIndex(key1, state);

        if(state.holding === key2) {
            return Math.abs(state.arm - Interpreter.findStackIndex(key1, state)) +
                objectsAboveKey(key1, state.stacks[key1StackIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK;
        }

        var key2StackIndex = Interpreter.findStackIndex(key2, state);
        var distance : number = Math.abs(key2StackIndex - key1StackIndex);

        return distance + objectsAboveKey(key1, state.stacks[key1StackIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK;
    }

    function distanceToKey(key:string, state:WorldState) {
        var stackIndex = Interpreter.findStackIndex(key, state);
        var objectsAboveStart = objectsAboveKey(key, state.stacks[stackIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK;
        var armIndex = state.arm;
        return Math.abs(armIndex - stackIndex) + objectsAboveStart;
    }

    function distanceBetweenKeys(k1:string, k2:string, state:WorldState) {
        var k1StackIndex = Interpreter.findStackIndex(k1, state);
        var objectsAboveK1 = objectsAboveKey(k1, state.stacks[k1StackIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK;

        var k2StackIndex = Interpreter.findStackIndex(k2, state);
        var objectsAboveK2 = objectsAboveKey(k2, state.stacks[k2StackIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK;

        return Math.abs(k1StackIndex - k2StackIndex) + objectsAboveK1 + objectsAboveK2;
    }

    function holdingHeuristic(literal:Literal, state:WorldState):number {
        var key = literal.args[0];
        if (state.holding === key) {
            return 0;
        }
        return distanceToKey(key, state);
    }

    function distanceBetweenArmAndKey(key : string, state : WorldState){
        return Math.abs(Interpreter.findStackIndex(key, state) - state.arm);
    }

    function insideOrOntopOrBelowHeuristic(literal:Literal, state:WorldState):number {
        var startKey = literal.args[0];
        var goalKey = literal.args[1];
        var distanceToGoal:number = 0;
        var distanceToStart:number = 0;

        if (goalKey === "floor") {
            if(startKey === state.holding) {
                return findClosestFloor(state.arm, state);
            } else {
                var startKeyIndex = Interpreter.findStackIndex(startKey, state);
                distanceToGoal = findClosestFloor(startKeyIndex, state);
                return Math.abs(state.arm - startKeyIndex) + objectsAboveKey(startKey, state.stacks[startKeyIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK + distanceToGoal;
            }
        }


        if(goalKey === state.holding) {
            var startKeyIndex = Interpreter.findStackIndex(startKey, state);
            return Math.abs(startKeyIndex - state.arm) + objectsAboveKey(startKey, state.stacks[startKeyIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK;
        } else if (startKey === state.holding) {
            var goalKeyIndex = Interpreter.findStackIndex(goalKey, state);
            return Math.abs(goalKeyIndex - state.arm) + objectsAboveKey(goalKey, state.stacks[goalKeyIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK;
        } else {
            var startKeyIndex = Interpreter.findStackIndex(startKey, state);
            var goalKeyIndex = Interpreter.findStackIndex(goalKey, state);
            var objectsAboveStart = objectsAboveKey(startKey, state.stacks[startKeyIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK;
            var objectsAboveGoal = objectsAboveKey(goalKey, state.stacks[goalKeyIndex]) * NBR_ACTIONS_NEEDED_TO_MOVE_OBJ_FROM_STACK;
            var distanceBetweenStartAndGoal = Math.abs(startKeyIndex - goalKeyIndex);
            var distanceBetweenArmAndStart = Math.abs(state.arm - startKeyIndex);

            return objectsAboveStart + objectsAboveGoal + distanceBetweenStartAndGoal + distanceBetweenArmAndStart;

        }

    }

    function objectsAboveKey(key:string, stack:string[]):number {
        return (stack.length - 1) - Interpreter.find(key, stack);
    }

    function findClosestFloor(index:number, state:WorldState):number {
        var closestFloor = Infinity;
        for (var i = 0; i < state.stacks.length; i++) {
            var curr:number = state.stacks[i].length + Math.abs(i - index);
            if (curr < closestFloor) {
                closestFloor = curr;
            }
        }
        return curr;
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan:string[];
    }

    export function stringify(result:PlannerResult):string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

    /**
     * The core planner function. The code here is just a template;
     * you should rewrite this function entirely. In this template,
     * the code produces a dummy plan which is not connected to the
     * argument `interpretation`, but your version of the function
     * should be such that the resulting plan depends on
     * `interpretation`.
     *
     *
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation:Interpreter.DNFFormula, state:WorldState):string[] {
        var start = new WorldWrapperNode(state, null);
        var graph = new WorldGraph();
        var goalFunction = (wwn:WorldWrapperNode) => goalReached(wwn.state, interpretation);
        var heuristicFunction = (wwn:WorldWrapperNode) => chooseCheapestLiteral(wwn.state, interpretation);
        var before = Date.now();
        var result = aStarSearch<WorldWrapperNode>(graph, start, goalFunction, heuristicFunction, 240);
        var after = Date.now();

        console.log("Ran in", after - before);

        var actions = result.path.map(wwn => wwn.action);
        actions.shift();
        return actions;
    }

}
