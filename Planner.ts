///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>

class WorldWrapperNode {
    state : WorldState;
    action : string;

    constructor(state: WorldState, action: string) {
        this.state = state;
        this.action = action;
    }
}

/**
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/

class WorldGraph implements Graph<WorldWrapperNode> {

    outgoingEdges(node : WorldWrapperNode): Edge<WorldWrapperNode>[]  {
        var edges : Edge<WorldWrapperNode>[];
        edges = [];
        var state = node.state;
        if(!state.holding) {
            if(state.stacks[state.arm].length > 0){
                edges.push(this.createPickUpActionEdge(node))
            }
        } else {
            if(state.stacks[state.arm].length > 0){

            } else {
                edges.push(this.createDropActionEdge(node))
            }
        }

        if(state.arm > 0) {
            edges.push(this.createLeftMoveActionEdge(node))
        }

        if (state.arm < state.stacks.length - 1) {
            edges.push(this.createRightMoveActionEdge(node))
        }
        //console.log("Outgoing edges", JSON.stringify(edges));
        //console.log("NbrOfEdges", edges.length);
        return edges;
    }

    compareNodes(s1 : WorldWrapperNode, s2 : WorldWrapperNode) : number {
        if (JSON.stringify(s1) === JSON.stringify(s2)) {
            return 0;
        } else {
            return 1;
        }
    }

    private createPickUpActionEdge(node : WorldWrapperNode) : Edge<WorldWrapperNode> {
        var e = new Edge<WorldWrapperNode>();
        e.cost = 1;
        e.from = node;
        var nextState = copyWorld(node.state);
        nextState.holding = nextState.stacks[nextState.arm].pop();
        e.to = new WorldWrapperNode(nextState, "p");

        return e;
    }

    private createDropActionEdge(node : WorldWrapperNode) : Edge<WorldWrapperNode> {
        var e = new Edge<WorldWrapperNode>();
        e.cost = 1;
        e.from = node;
        var nextState = copyWorld(node.state);
        //console.log("About to push:", nextState.holding);
        nextState.stacks[nextState.arm].push(nextState.holding);
        nextState.holding = null;
        e.to = new WorldWrapperNode(nextState, "d");
        return e;
    }

    private createLeftMoveActionEdge(node : WorldWrapperNode) : Edge<WorldWrapperNode> {
        var e = new Edge<WorldWrapperNode>();
        e.cost = 1;
        e.from = node;
        var nextState = copyWorld(node.state);
        nextState.arm--;
        e.to = new WorldWrapperNode(nextState, "l");
        return e;
    }

    private createRightMoveActionEdge(node : WorldWrapperNode) : Edge<WorldWrapperNode> {
        var e = new Edge<WorldWrapperNode>();
        e.cost = 1;
        e.from = node;
        var nextState = copyWorld(node.state);
        nextState.arm++;
        e.to = new WorldWrapperNode(nextState, "r");
        return e;
    }


    
}

function copyWorld(s : WorldState) : WorldState {
    return JSON.parse(JSON.stringify(s));
}

function obaysPhysicalLays(key1 : string, key2 : string, state : WorldState) : boolean {
    return true;
}
    
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
        var errors : Error[] = [];
        var plans : PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result : PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch(err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    function goalReached(state : WorldState, interpretation : Interpreter.DNFFormula) : boolean{
       // console.log("foalREached");

      for(var i = 0; i < interpretation.length; i++){
        for(var j = 0; j < interpretation[i].length; j++){
          var literal = interpretation[i][j];
          var relation  = literal.relation;
            //console.log(relation);
          if(relation === "holding" && state.holding === literal.args[0]){
            return true;
          } else {
              var fKey = [literal.args[0]];
              var sKey = [literal.args[1]];

              //if this goal interpretation is reached, checkBinaryConstraint
              //will return a nonempty list
              var isGoal = Interpreter.checkBinaryConstraint(sKey, fKey, relation, state);
            //  console.log("isGoal", isGoal, fKey, sKey, relation, JSON.stringify(state, null, 2));
              if(isGoal.length === 1){
                  console.log("Winning");
                  return true;
              }
          }
        }
      }
      return false;
    }

    function chooseCheapestLiteral(state : WorldState, interpretation : Interpreter.DNFFormula) : number{
        //console.log(interpretation);
        var literal = interpretation[0][0];
        var oldHeuristic : number = 0;

        if(literal.relation === "holding"){
          oldHeuristic = unaryHeuristic(state, literal.args[0]);
          for(var i = 1; i < interpretation.length; i++){
            for(var j = 1; j < interpretation[i].length; j++){
              var tmp = unaryHeuristic(state, interpretation[i][j].args[0]);
              if(tmp < oldHeuristic){
                oldHeuristic = tmp;
                literal = interpretation[i][j];
              }
            }
          }
        }else{
            //  console.log(literal.args);
          oldHeuristic = binaryHeuristic(state, literal.args[0], literal.args[1]);
          for(var i = 1; i < interpretation.length; i++){
            for(var j = 1; j < interpretation[i].length; j++){
              var tmp = binaryHeuristic(state, interpretation[i][j].args[0], interpretation[i][j].args[1]);
              if(tmp < oldHeuristic){
                oldHeuristic = tmp;
                literal = interpretation[i][j];
              }
            }
          }
        }

      return oldHeuristic;
    }

    function unaryHeuristic(state : WorldState, startKey : string) : number{
      var armIndex = state.arm;
      var startColumn = Interpreter.findStackIndex(startKey, state);

      var startStack = state.stacks[startColumn];

      var objectsAboveStart = (startStack.length - 1) - Interpreter.find(startKey, startStack);

      return Math.abs(armIndex - startColumn) + objectsAboveStart;
    }

    function binaryHeuristic(state : WorldState, startKey : string, goalKey : string) : number{
      var armIndex = state.arm;

      var goalColumn = 0;
        if(goalKey === "floor") {
            goalColumn = 1;
        } else {
            goalColumn = Interpreter.findStackIndex(goalKey, state);
        }
        console.log(goalKey);
      var startColumn = Interpreter.findStackIndex(startKey, state);
        console.log("goalColumn", goalColumn);
      var goalStack = state.stacks[goalColumn];

        console.log("goalSTack", goalStack);
        console.log("goalSTackLength", goalStack.length);
      var objectsAboveGoal = (goalStack.length - 1) - Interpreter.find(goalKey, goalStack);

      return Math.abs(startColumn - goalColumn) +
        objectsAboveGoal + unaryHeuristic(state, startKey);
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan : string[];
    }

    export function stringify(result : PlannerResult) : string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

    /**
     * The core planner function. The code here is just a template;
     * you should rewrite this function entirely. In this template,
     * the code produces a dummy plan which is not connected to the
     * argument `interpretation`, but your version of the function
     * should be such that the resulting plan depends on
     * `interpretation`.
     *
     *
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
        console.log("\nPlanInterpretation");
        var start = new WorldWrapperNode(state, null);
        var graph = new WorldGraph();
        
        var goalFunction = (wwn:WorldWrapperNode) => goalReached(wwn.state, interpretation);
        var heuristicFunction = (wwn:WorldWrapperNode) => chooseCheapestLiteral(wwn.state, interpretation);
        console.log("Doing aStarSearch");
        try {
            var result = aStarSearch<WorldWrapperNode>(graph, start, goalFunction, heuristicFunction, 120);
            console.log("Search complete");
            console.log(result, "\n");
            var actions = result.path.map(wwn => wwn.action);
            actions.shift();
            console.log("Actions: ", actions);
            return actions;
        } catch (err) {
            console.log("Error", err);
            throw err;
        }

    }

}
